%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[preprint, numbers, 10pt]{sigplanconf}

%\documentclass[pldi]{sigplanconf-pldi16}
%\documentclass[pldi-cameraready]{sigplanconf-pldi16}


% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% numbers       To obtain numeric citation style instead of author/year.

\usepackage{amsmath}
\usepackage{etoolbox}

\newcommand{\cL}{{\cal L}}

\usepackage[linesnumbered, ruled]{algorithm2e}

% added by yqp
\usepackage{mdwlist}% Compact list formats \itemize*, \enumerate*
\usepackage{listings}
\usepackage{amssymb}
\usepackage{multirow}
\usepackage{mathrsfs}

\usepackage{enumerate}
\usepackage{tabularx}
\usepackage{times}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{epsfig}
\usepackage{wrapfig}
%\usepackage{algp1seudocode}
\usepackage{url}
\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{xcolor}
\usepackage{algorithmicx}
\usepackage{amssymb}% h6ttp://ctan.org/pkg/amssymb
\usepackage{pifont}% http://ctan.org/pkg/pifont

\usepackage{colortbl}
\definecolor{mygray}{gray}{0.85}

%%%%%%%%%%%%%%%%%%%%%%%%
% User-defined keywords
%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\true}{\mathsf{true}}
\newcommand{\false}{\mathsf{false}}
\newcommand{\Instr}{\mathit{Instr}}
\newcommand{\instr}{\mathit{instr}}
%\newcommand{\comment}[1]{}
\newcommand{\textcode}[1]{\texttt{\small #1}}
\newcommand{\inv}{\textcode{inv}}
\newcommand{\resp}{\textcode{resp}}
\newcommand{\edge}[1]{\stackrel{#1}{\longrightarrow}}
\newcommand{\Ind}[1]{\hspace{#1ex}\hspace{#1ex}\hspace{#1ex}}
\newcommand{\revise}[1]{\textcolor{blue}{#1}}

\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%
\newcommand{\across}{\textsf{ARC}}
\newcommand\qynote[1]{\textcolor{green}{{\textbf{Qiuping Says: #1}}}}
\newtheorem{observation}{Observation}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{example}{Example}

\newcommand{\acquire}{\textit{Lock}}
\newcommand{\release}{\textit{Unlock}}
\newcommand{\join}{\textit{ThreadJoin}}
\newcommand{\fork}{\textit{ThreadFork}}
\newcommand{\writ}{\textit{Write}}
\newcommand{\rea}{\textit{Read}}
\newcommand{\tbegin}{\textit{ThreadBegin}}
\newcommand{\tend}{\textit{ThreadEnd}}

\newcommand{\checker}{\textsc{Checker$^{11}$}}

\makeatletter
\patchcmd{\maketitle}{\@copyrightspace}{}{}{}
\makeatother
\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country}
\copyrightyear{20yy}
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm}
\copyrightdoi{nnnnnnn.nnnnnnn}

% Uncomment the publication rights you want to use.
%\publicationrights{transferred}
%\publicationrights{licensed}     % this is the default
%\publicationrights{author-pays}

%\titlebanner{banner above paper title}        % These are ignored unless
%\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Maximal Causality Reduction across Inputs}
%\subtitle{Subtitle Text, if any}

\authorinfo{Name1}
           {Affiliation1}
           {Email1}
\authorinfo{Name2\and Name3}
           {Affiliation2/3}
           {Email2/3}

\maketitle

\begin{abstract}

\end{abstract}

%\category{CR-number}{subcategory}{third-level}
%\category{CR-number}{Formal Methods}{Model Checking}

% general terms are not compulsory anymore,
% you may leave them out
%\terms
%term1, term2

%\keywords
%Model Checking, Symbolic Execution, Concurrent Program

%\input{Introduction.tex}
%\input{Overview.tex}
%\input{ApproachNew.tex}
%\input{Evaluation}
%\input{RelatedWork}
%\input{Conclution}

\section{Introduction}

A important trend in hardware and compiler is that 
they introduce relaxed-memory behavior, and thus involve 
a tension between the usability and performance. 
Obviously, a very strong memory model, such as sequential 
consistency (SC), simplifies reasoning about the permitted 
program behavior but at a cost of sacrificing the performance 
with disabling many compiler optimizations, and requiring
expensive synchronization instructions (such as fences). 

The C++11 provides various \textit{atomic} primitives 
with weaker semantics for high-performance
concurrent algorithms. The users can use SC \textit{atomics} 
when concurrent accesses are needed but performance is not a 
critical concern. Otherwise, they can use the low-level 
\textit{atomics} provided by C++11. Actually, the low-level 
atomics provide a common abstraction above the widely used 
hardware, including X86, Sparc, Power and ARM. As expected 
by the C++11 designer, only a small fraction of programmers 
will use low-level atomics to design performance-critical 
code, such as concurrent data structures, basic concurrent 
libraries and OS kernels. However, the possible behaviors of 
the so-called small fraction of code are needed to be 
thoroughly checked, since they not only affect the performance, 
but more importantly may introduce tricky bugs which are difficult
to be identified.


\section{C++11 Memory Model}

Standardization committees have extended the C and C++ language 
standards~\cite{ISO1, ISO2} into C/C++11, which supports low-level 
atomic operations to allow programmers to design efficient 
code without the overheads of locks. 

\subsection{Atomic Operations}
\label{sec:operations}

The C/C++11 standards provide several low-level atomic operations
on atomic types to allow multiple threads to interact, including
stores, loads, read-modify-writes (RMWs) and fences. RMWs modify
the existing value of an atomic location, storing the new value
and at last returning the previous value atomically. Fences provide
finer control over synchronization among atomic operations. 

Each atomic operation is annotated with one of six memory orderings: 
relaxed, consume, acquire, release, acquire-release and 
sequentially consistent, which control how operations are ordered
between threads and when synchronization occurs. They are described 
as follow: 

\begin{itemize}
\item \textbf{memory\_order\_relaxed: } weakest memory ordering.
\item \textbf{memory\_order\_release: } a store-release may form
release/consume or release/acquire synchronization.
\item \textbf{memory\_order\_consume: } a load-consume may form
release/consume synchronization.
\item \textbf{memory\_order\_acquire: } a load-acquire may form
release/acquire synchronization.
\item \textbf{memory\_order\_acq\_rel: } a read-modify-write operation
with this memory order is both an acquire and release operation.
\item \textbf{memory\_order\_seq\_cst: } strongest memory ordering.  

\end{itemize}

One valuable observation about \textit{memory\_order\_consume} 
is that it can be safely replaced with \textit{memory\_order\_acquire}. 
Since acquire operations provide all of the guarantees of consume 
operations. Today’s compiler support for \textit{memory\_order\_consume} 
is lacking, thus we omit this memory order in this paper. 

\subsection{Relations in C++11}
\label{sec:relations}

Actually, the memory model formalizes the set of executions that are allowed
for a given C++11 program. Specifically, the relations among the
actions along the allowed executions can be described through several 
steps, as described in~\cite{Batty10,Batty:2011}. Note that we consider 
all actions including the reads, writes, locks, unlocks and fences. 

This paper follows the denotation in~\cite{Batty:2011} to concisely
represent different types of memory actions. 
Specifically, each action is annotated with a unique identifier, such as \textit{a} or \textit{b}. 
In addition, R/W respectively represents a read/write, RMW for read-modify-write, 
L/U for a lock/unlock, and F for a fence. A subscript \textit{mo} is used to abbreviate the memory
order for each action with specified memory order. 
\textit{mo} has seven different values: RLX, REL, CON,  ACQ, A/R, SC, respectively
represents the sequentially listed memory order in Section~\ref{sec:operations}, and 
na is used for non-atomic operations. 

\subsubsection{Relations determined by syntax and control-flow}
\label{sec:relation1}

Without taking memory model into consideration, two relation types 
can be determined by program syntax and control-flow: 
\textit{sequenced-before} and \textit{additional-synchronized-with}.


\paragraph{sequenced-before} 
\textit{sequenced-before} (\textit{sb}) is an asymmetric, transitive, 
pair-wise relationship between evaluations within the same thread.
Note that some operations in C/C++ provide no intra-thread 
ordering, such as operator '==' and '+'. 
Taking expression \textit{$f_1() + f_2() + f_3()$} as example, 
the function call to $f_3$ may be evaluated first, last, 
or between $f_1()$ or $f_2()$ at run time. As shown in Figure~\ref{fig:sb_relation},
it describes a simple program with only one thread and the sequenced-before
relations among its actions. 

\begin{figure}%[t]
\centering\includegraphics[scale=0.5]{sb_Relation.pdf} %[width=6in]
\caption{A simple example with one thread (on the left) and the \textit{sb}
relations among its actions (on the right).}
\label{fig:sb_relation}
\end{figure}

\paragraph{additional-synchronized-with}
The standard describes several situations that 
give rise to synchronization edges between actions. 
Apart from the main case described by synchronizes-with relation
(defined in Section~\ref{sec:relation3}), \textit{additional-synchronized-with} (\textit{asw}) 
describes all of the other cases. It mainly contains additional synchronization 
edges from thread creation and thread join among others.
Generally, synchronization edges order one part of program execution 
before another. Figure~\ref{fig:asw_relation} describes the \textit{asw} relations
for a simple example. 

\begin{figure}%[t]
\centering\includegraphics[scale=0.5]{asw_Relation.pdf} %[width=6in]
\caption{A simple example with two threads (on the left) and the \textit{sb} 
and \textit{asw} relations among its actions (on the right).}
\label{fig:asw_relation}
\end{figure}

\paragraph{pre-executions.}
Based on the two relations described above, 
\textit{pre-executions} can be defined as the program
executions which are compatible with the instructions of the individual 
threads without considering the behaviour of shared memory. 
In other words, a pre-execution is determined by \textit{sb} edges
and \textit{asw} edges.
Generally, \textit{pre-executions} are an over-approximation of the executions 
that will ultimately be allowed to happen once the whole program and 
the memory model are taken into account.

\subsubsection{Witness Relations}
\label{sec:relation2}

For each pre-execution, we can enumerate all its possible
\textit{candidate executions}, which comprise three more
relations: \textit{rf} (a reads-from map), modification-order (a coherence order), 
and \textit{sc} (an order over sequentially consistent actions). Specifically,
the added three relations are used to characterize the 
interrelationship between memory actions of different threads and thus
the behavior of a particular execution. Note that, not all 
pre-executions can be extended to a candidate execution. 
For example, a read cannot be matched with an expected write.

\paragraph{Reads-from}

This relation relates each write to every read that takes its value 
from that write. Note that the reads-from(rf) edges must relate writes 
and reads with the same value to guarantee a consistent execution. 
This relation is non-trivial, since in any given execution of a C++11 program, 
there are usually many stores that a load can read from. As described in
Figure~\ref{fig:rf_relation}, action \textit{c} is related to action \textit{d},
because \textit{d} reads the value written by \textit{c}. \textit{mo} and 
\textit{sc} edges will be described in the following section.  

\begin{figure}%[t]
\centering\includegraphics[scale=0.5]{rf_Relation.pdf} %[width=6in]
\caption{A simple example with three threads (on the left) and 
its three witness relations relations among its actions (on the right).}
\label{fig:rf_relation}
\end{figure}

\paragraph{Modification-order}

For each atomic location, a candidate execution has a total order 
of the writes to that location. The union of all these relations 
is modification-order. This relation represents a memory-coherent
ordering in which the stores may be observed. 
Note that in general the modification orders for different objects 
cannot be combined to form a consistent total ordering, 
thus each location has its own order. As shown in Figure~\ref{fig:rf_relation},
the write actions \textit{a} and \textit{c} have a \textit{mo} relation with
\textit{mo} edge from \textit{a} to \textit{c}. 

\paragraph{Sequentially Consistent Order}

A program execution has a total order, \textit{sc}, over all 
of the atomic actions with sequentially consistent memory order 
and all of the lock and unlock actions of the program. 
This relation removes a lot of the weak behaviors that 
an execution could exhibit. 
For example, for a load \textit{a} and store \textit{b} both with 
sequentially consistent memory order, \textit{a} can not read from
\textit{b} when \textit{b} is prior to the most recent store in 
the \textit{sc} ordering. Taking Figure~\ref{fig:rf_relation} as 
an example, read \textit{d} cannot read from write \textit{a}, because
\textit{a} is pripr to \textit{c} which is in the same \textit{sc} ordering with \textit{d}. 


\subsubsection{Derived Relations}
\label{sec:relation3}

As described above, a candidate execution comprises its actions,
the relations determined by the syntax and control-flow, and 
the witness relations. To judge whether the execution follows 
the rules set out by the memory model and thus a consistent 
execution, several derived relations can be derived. 
These relations are completely determined by a candidate execution.

\paragraph{Release Sequence}

A release action is an atomic write or fence that has one of the 
three memory order: \textit{mo\_release}, \textit{mo\_acq\_rel},
and \textit{mo\_seq\_cst}. Each release write has a corresponding 
\textit{release sequence} (\textit{rs}), which is the longest continuous 
subsequence of the modification order that starts with the release
write, and each write in the sequence is performed by the same thread 
as the release or a atomic read-modify-write operations by any thread.
Note that the writes by other threads will break the sequence, however,
a RMW from another thread will continue it. Figure~\ref{fig:rs_relation}
describes one release sequence which is interrupted by a write action
from another thread. Note that the head of a release sequence has a 
\textit{rs} relation with itself.

\begin{figure}%[t]
\centering\includegraphics[scale=0.45]{rs_Relation.pdf} %[width=6in]
\caption{The release sequence begins at release action \textit{b}, and
ends at action \textit{d}. It contains three actions: 
\textit{b}, \textit{c}, and \textit{d}, and is interrupted by action \textit{g}.}
\label{fig:rs_relation}
\end{figure}

\paragraph{Synchronizes-with}

This relation defines the points in an execution where
one thread has synchronised with another. 
An acquire action is an atomic read or fence that has 
either \textit{mo\_acquire}, \textit{mo\_acq\_rel}, \textit{mo\_seq\_cst} 
or \textit{mo\_consume} memory order. A release action synchronizes 
with an acquire action from another thread if the acquire action 
reads from a write in the \textit{release sequence} of the release. Then, 
a synchronizes-with (\texttt{sw}) edge exists between the acquire and 
release actions in the execution. 
This relation also occurs between consecutive unlock and lock 
operations on the same mutex, between thread creation and join.
Actually, an \textit{asw} edge is also an \textit{sw} edge.

\begin{figure}%[t]
\centering\includegraphics[scale=0.4]{sw_Relation.pdf} %[width=6in]
\caption{\textit{sw} edges generated from thread creates and 
release-acquire pairs. }
\label{fig:sw_relation}
\end{figure}

In Figure~\ref{fig:sw_relation}, the \textit{sw} edge from \textit{b} to \textit{c}
and from \textit{b} to \textit{f} are generated by thread creations. In addition,
the \textit{sw} edge from \textit{c} to \textit{d}, and that from \textit{e} to
\textit{f} are both generated by release-acquire pairs. 

\paragraph{Happens-before}

This is the main derived relation, which is an inter-thread relation 
collecting several ordering relations, discussed so far. 
Without considering memory order \textit{mo\_consume}, 
Happens-before (\textit{hb}) is defined as the transitive 
closure of \textit{sb} and \textit{sw}, represented as $(sb\cup sw)^+$. 
As described in Figure~\ref{fig:sw_relation}, \textit{bf} edges is consistent
with \textit{sb} and \textit{sw} relations.  
%(where + denotes transitive closure).
% representing Lamport’s partial ordering over the events in a system [25]. Because an sw edge is also an hb edge, when thread A synchronises with thread B, every side effect that has occurred inAup to this point will become visible to every event issued by B from this point.
%Data

\paragraph{Visible-side-effect}

In a consistent execution, the writes that can be read by a given read 
are decided by the happens-before relation. Specifically, the writes that
happens before the read with no intervening write is a\textit{ visible side effect} 
of the read. For example, a write $A$ is visible with respect to a read $B$ if 
$A$ happens before $B$, and no other write $X$ happens $B$ but after $A$. 
%Non-atomic reads must read from one of their visible-side-effects.
%Differently, 
For atomic reads, their visible side effects decide the earliest writes 
in modification order that the reads may be read. 
There can be at most one visible side effect for any load. 
%This can lead to cases where there are no visible side effects for a given load, 
%due to locations being initialised from another thread which has yet to synchronise with. 
%Locations that are initialised by the global thread will therefore overcome this issue.

\paragraph{Visible-sequence-of-side-effects} 

Atomic reads take their values from a write in a visible sequence of side effects of the read. This is a contiguous part of themodification order that starts with a visible side effect and ends before the first write that the read happens- before. In our diagrams of executions, we draw these sequences as vsses edges from their elements to the read that they correspond to (the order among the sequence is simply modification order). The following execution shows a read from a write in a visible- sequence-of-side-effects.


\subsection{Consistent Executions}

Based on the currently defined relations, we can check whether a given 
candidate is a consistent execution. 
The C++11 memory model is axiomatic, and it provides a set of axioms 
to described an execution which may be exhibited by a program.
Only when a candidate execution conforms these axioms, then it is 
said to be consistent. Inconsistent executions need not to be taken into 
consideration, because they will never occur by any actual execution. 

Seven consistent axioms are proposed in~\citep{Batty:2011} to guarantee
the consistency of executions. 
The \textit{well\_formed\_threads} axiom requires that \textit{sb} must 
be intra-thread and a strict pre-order, an irreflexive and transitive order.
The \textit{well\_formed\_rf\\\_mapping} axiom ensures \textit{rf} relation
enforce consistent behavior among different actions. For example, 
$a \stackrel{rf}{\longrightarrow} b$ implies that load \textit{b}
must read the value that a writes. 
The \textit{consistent\_locks} axiom states that the lock and unlock actions
at the same location is a strict total order, and it describes the similar
relation with that in C++ programs with sequential consistency memory model. 
The last three axioms, \textit{consistent\_sc\_order}, \textit{consistent\_mo} 
and \textit{consistent\_rf\_mapping}, correspond with the formation of the 
three derived relations: \textit{sc}, \textit{mo} and \textit{rf}. 
We do not consider \textit{consistent\_inter\_thread\_happens\_before}
relation with \textit{consume} operations, thus it simply requires \textit{hb} to 
be irreflexive. 

For thoroughly checking a C++11 program, we need to identify all the undefined
behaviors that may happen in a consistent execution. It is a tricky problem, since 
some weak behavior, not allowed by sequential consistent memory model,
can only happen with the effect of compiler reorderings and the hardware on 
which a program is executed. 

\section{Background...}
Add a simple introduction about maximal causality reduction and MCR. ...

\section{Our Approach}
\label{sec:approach}

Our approach, \checker, explores all consistent execution of a C++11 program allowed
by its memory model to identify abnormal behaviors based on
a constraint-solving method. Specifically, whenever a new execution is observed,
It identifies new unexplored consistent executions, and generates a corresponding schedule to
trigger each execution. In the following section, we first presents the main workflow in Section
~\ref{sec:workflow}, and then describes the constraints encoding approach for 
consistent executions generation in Section~\ref{sec:encode}. 

\subsection{The Main Workflow of \checker}
\label{sec:workflow}

Algorithm~\ref{alg:top} describes the main work flow of \checker. 
For a given C++11 program $P$, it firstly initializes the \textit{to-be-checked}
work list $workList$ with a random schedule $sch$, then it follows an
iteration process (line 4$\sim$11). For each iteration, it firstly gets an unexplored 
schedule $sch$ from $workList$ at line 5, and then carries out a concrete
execution to follow $sch$ at line 6. Line 7 constructs the constraints 
of maximal causal model (described in Section~\ref{sec:encode}), which will
be checked offline at line 8 (described in Section~\ref{sec:check}). 
At the end of each iteration, $workList$ will be updated at line 10 with newly
identified schedules based on the currently observed trace $\tau$ at line 9. 


\begin{algorithm}%[t]
  \caption{{\bf The main workflow of \checker.}}
%  its cycles as potential deadlocks.}}%: The top algorithm.
  \label{alg:top}
{%\footnotesize
\begin{algorithmic}[1]
  \State{\Ind{0} \textbf{Input:} C++11 Program $P$;}
%  \State{\Ind{0} \textbf{Output:} potential deadlocks $deadlocks$;}
  \State{\Ind{0} Let $sch$ be a random schedule;}
  \State{\Ind{0} $workList.add(sch)$;}
  \State{\Ind{0} {\bf while} ($workList\neq \emptyset$)}
  \State{\Ind{1} {		$sch\leftarrow workList.pop()$;}}
  \State{\Ind{1} {		$\tau\leftarrow$ \bf Execute$(P, sch)$;}}
  \State{\Ind{1} {		$\Phi\leftarrow$ \bf ConstructMaxCausalModel$(\tau)$;}}
  \State{\Ind{1} {		\bf PropertyCheck$(\Phi)$;}}
  \State{\Ind{1} {		$sch\_List\leftarrow$ \bf IdentifyNewSch$(\tau, \Phi)$;}}
  \State{\Ind{1} {		$workList.add(sch\_List)$;}}
  \State{\Ind{0} {\bf end while}}

\end{algorithmic}
}
\end{algorithm}

\subsection{Constraints Encoding of Maximal Causal Model}
\label{sec:encode}

As described in~\cite{Huang:2015}, while encoding the maximal causal model 
for the programs with sequential consistency memory model, only variables of 
the form $O_e$ corresponding to each even $e$ are needed. Specifically,
these variables denote the order of the events in a given trace $\tau$. 
Unfortunately, such order variables are insufficient to describe the executions
for C++11 programs, since a strict total order does not exist among 
the events from a given trace without the guarantee of sequential consistency 
memory model. Figure~\ref{fig:noStrictOrder} describes such an execution. 
%For example, even if two different memory locations are written 
%by the same thread in sequence, the two newly written values may be observed 
%in different order by other threads. 

\begin{figure}%[t]
\centering\includegraphics[scale=0.5]{noStrictOrder.pdf} %[width=6in]
\caption{A strict total order does not exist among the events from an 
execution of C++11 program, and a feasible VC encode.}
\label{fig:noStrictOrder}
\end{figure}

\subsubsection{Vector Clocks}

To describe the precise happens-before relation for the
event for C++11 programs, we use a Lamport-style 
clock vector~\cite{Lamport:1978} and enforce similar extension 
in~\cite{Lidbury:2017,Norris:2013}. Specifically, 
we define a clock $C_i$ for each thread $T_i$ to represent
its own logical time. $C_i$ is initialized to 0 and increases following 
each \textit{sb} edge. In addition, for each event $e$, 
we define a clock vector $\mathbb{C}_e=(c_1, c_2, ..., c_N)$, 
which contains a clock for each thread, where $c_i=\mathbb{C}_e(i)$ 
represents a clock value of thread $T_i$ at event $e$. Synchronization between thread $T_i$
and $T_j$ because of edge $e_i \stackrel{sw}{\longrightarrow} e_j$ should 
merge $\mathbb{C}_{e_i}$ into $\mathbb{C}_{e_j}$, according to a pairwise maximum 
over all the thread clocks. 

Figure~\ref{fig:noStrictOrder} describes a feasible VC encode. 
The VC can describe all happens-before facts. 
For example, $a \stackrel{hb}{\longrightarrow} c$, $a \stackrel{hb}{\longrightarrow} d$,
$a \stackrel{hb}{\longrightarrow} e$, and $a \stackrel{hb}{\longrightarrow} f$. 
The VC at event $c/e$ is updated according that at event $b$ because of edge 
$b \stackrel{sw}{\longrightarrow} c/e$. 
However, no happens-before relation is enforced between events  $c/d$ and
$e/f$. Thus, it is possible that both event $c$ and $e$ can read value 1 as described
in Figure~\ref{fig:noStrictOrder}. 

%we define a clock $C_i$ for each thread $T_i$ to represent
%its logical time, and assign a number $C_i(a)$ to any event in the thread. 
%$C_i$ is initialized to 0 and increases following each \textit{sb} edge. 
%In addition, each thread $T_i$ has its own vector clock (VC), $\mathbb{C}_{i}$, which
%holds a clock for each thread. Each clock in $\mathbb{C}_{i}$ represents the logical 
%time of the last instruction by the thread $T_i$ that happens before 
%any instruction $T_i$ will execute. We denote the clock for thread $T_j$ in
%$\mathbb{C}_{i}$ at event $a$ as $\mathbb{C}_{i}(j)(a)$. 
%Note that $\mathbb{C}_{i}(i)(a)$ equals to $C_i(a)$. Synchronization between thread $T_i$
%and $T_j$ because of edge $T_i \stackrel{sw}{\longrightarrow} T_j$ should 
%merge $\mathbb{C}_{i}$ into $\mathbb{C}_{j}$, according to a pairwise maximum 
%over all the thread clocks. 

To compare two vector clocks
$\mathbb{C}_a$ and $\mathbb{C}_b$, we define $'<'$ relation among them and
claim $\mathbb{C}_a < \mathbb{C}_b$ only when $\forall i\in \{1,..,N\}, \mathbb{C}_a(i)\leq \mathbb{C}_b(i)$. 
They are not comparable when $\mathbb{C}_a\not<\mathbb{C}_b\wedge\mathbb{C}_b\not<\mathbb{C}_a$, 
represented as $\mathbb{C}_a ||\mathbb{C}_b$. 
Actually, $\mathbb{C}_a < \mathbb{C}_b$ implies happens-before relation among $a$ and $b$, 
and no such relation is enforced when $\mathbb{C}_a$ and $\mathbb{C}_b$ are not comparable.
For example, event $c$ does not have happens-before relation with $e$, thus $\mathbb{C}_c < \mathbb{C}_e$.


\subsubsection{Constraint Encoding}

From a high level view, $\Phi$ can be encoded based on $\mathbb{C}$ of the given trace, which denote
the order of the events in trace $\tau$. According to the event relations described
in Section~\ref{sec:relations}, $\Phi$ is constructed by a 
conjunction of four sub-formulas: $\Phi\equiv\Phi_{mhb}\wedge\Phi_{sw} \wedge\Phi_{rw}\wedge\Phi_{co}$,
where $\Phi_{mhb}$ contains $\Phi_{sb}$, the constraints of \textit{sequence-before} relations, 
and $\Phi_{asw}$, the constraints of \textit{additional-synchronized-with} relations. 
$\Phi_{sw}$ encodes the \textit{synchronizes-with} relations and 
$\Phi_{rw}$ encodes the data-validity constraints, enforced by the combined relations of $rf$, $mo$, and $sc$.  
The last conjunct $\Phi_{co}$ encodes the memory coherence constraints. 

%conjunction of two sub-formulas: $\Phi\equiv \Phi_{1}\wedge \Phi_{2}$, where 
%$\Phi_1=\Phi_{sb}\wedge \Phi_{asw}$ represents the relations determined by syntax 
%and control-flow and $ \Phi_2 = \Phi_{rf}\wedge\Phi_{mo}\wedge\Phi_{sc}$ represents
%the witness relations. 

\paragraph{Encode must-happens-before relations $\Phi_{mhb}$}

We call the relations determined by syntax and control-flow must-happen-before relations,
which reflect a subset of happens-before relation and contain two parts: sequenced-before
relations and additional-synchronized-with relations. 

The encode for relations $sb$, $\Phi_{sb}$, is very straightforward, because it only 
consider the relations among the events from the same thread. Based on the variables representing
the encode of VC, we can simply encode $\Phi_{sb}$ by initializing it to $true$ and 
conjunct it with a new constraint $\mathbb{C}_a<\mathbb{C}_b$, whenever 
$a$ and $b$ are events from the same thread and $a \stackrel{sb}{\longrightarrow} b$.
Specifically, $\Phi_{sb}$ can be encoded as follow:

\begin{equation}
\begin{aligned}
\Phi_{sb} ={} & \bigvee_{\forall T_i\in T} (\bigvee_{\forall a,b\in T_i\wedge a \stackrel{sb}{\longrightarrow} b} 
								(\mathbb{C}_a<\mathbb{C}_b)
\end{aligned}
\end{equation}

The encode for additional-synchronized-with relations mainly reflects 
the VC update at thread creation and join points. 
Specifically, for each thread creation/join event pair $CJ(a, b)$, 
where $a$ in thread $T_i$ creates/joins to 
thread $T_j$ and $b$ is the first/last instruction of $T_j$, the vector clock 
$\mathbb{C}_a$ must be merged into $\mathbb{C}_b$. 
Let $max(x,y)$ be the maximal value between $x$ and $y$ and $N$ the
number of threads, then $\Phi_{asw}$ can be encoded as follow: 

\begin{equation}
\begin{aligned}
\Phi_{asw} =\bigvee_{\substack{\forall CJ(a,b), \\a\in T_i, b\in T_{j},\\k\in\{1..N\}}} 
					(\mathbb{C}_b(k)=max(\mathbb{C}_a(k), \mathbb{C}_b(k))
\end{aligned}
\end{equation}

\paragraph{Encode synchronizes-with relations $\Phi_{sw}$}

Apart from additional-synchronized-with synchronization, C++11 programs 
contain three other types of synchronizes-with relations: 
mutex synchronization, release/acquire synchronization and fence synchronization. 
%In this section, we mainly elaborate the encoding of release-acquire synchronization.

To encode the release-acquire synchronizations, we need to compute the release sequences
along $\tau$. %, represented as $rsSet$. 
Only when a acquire-read $r$ reads from one write $w$,
which belongs to the release sequence $S$ with release head $x$, the \textit{sw} edge 
$x \stackrel{sw}{\longrightarrow} r$ exists. Thus this relation can not be enforced 
as must-happen-before relation, and directly conjuncted into $\Phi$. 
Let $acq(r)$ be $true$ only when event $r$ is a acquire-read,
$rf^r_w$ be $true$ only when $r$ reads from $w$, and
$rsh(w)$ the head of the release sequence which $w$ belongs to, then 
we can define $\Phi_{sw}$ as follow: 
%For each read-write pair $(r, w)$, we define $\Phi_{sw}(r, w)$ as follow: 

%\begin{equation}
%\begin{aligned}
%\Phi_{sw} =\bigvee_{\substack{\forall r,w\in \tau}}
%					rf(r,w)\wedge rsh(w)\neq null \rightarrow \mathbb{C}_{rsh(w)}<\mathbb{C}_r 
%\end{aligned}
%\end{equation}

\begin{equation}
\begin{aligned}
\Phi_{sw} =\bigvee_{\substack{\forall r,w\in \tau}}\phi_{sw}(r,w)
\end{aligned}
\end{equation}

where $\phi_{sw}(r,w)$ is defined with $x=rsh(w)$ as follow: 

\[ \left\{
  \begin{array}{l l}
    \mathbb{C}_{x}<\mathbb{C}_r,           &  {\text{if $acq(x)\wedge rf^r_w\wedge x\neq null$}};\\\\
    true,  &  \text{otherwise}.
  \end{array} \right.\]

%Since the read-write synchronization can be enforced only when a acquire-read is matched with 
%a release-write, we enforce such synchronization while encoding data-validity constraints, 
%as described later. 

\paragraph{Encode data-validity constraints $\Phi_{rw}$}

As described in~\cite{Huang:2015}, the data-validity constraints
ensure that every event in the considered trace $\tau$ is feasible. 
Specifically, to guarantee the feasibility of an event, we require that
all the events that must-happen-before it should be feasible. Thus,
every read event that must-happen-before it should read the same value
as that in the input trace $\tau$.  

To describe all executions which exhibit the similar behavior as trace $\tau$, 
we do not require each read to read the value written by the exact same write event
as in trace $\tau$ but any possible write, as long as all required constraints
can be satisfied. For example, if more than one writes write the same value read
by a read event, then the read may read the value written by any write.  

Let $\Phi_{rw}(e)$ be the constraint of the reachability of event $e$ in trace $\tau$,
and  $\stackrel{mhb}{\longrightarrow} e$ the set of events that must-happen-before
the event $e$. For each read $r$ in set  $\stackrel{hb}{\longrightarrow} e$, $\Phi_{rw}(e)$
requires that $r$ must read the same value as that in $\tau$, represented as $value(r, \tau)$. 
Suppose the set $W^x$ contains all the writes which write to location $x$, 
and the set $W_v^x\subseteq W^x$ contain these which write value $v$, then
$\Phi_{rw}(e)$ can be described as follow: 

\begin{equation}
\begin{aligned}
\Phi_{rw}(e) ={} & \bigvee_{\forall r\in \stackrel{mhb}{\longrightarrow} e} 
					(\Phi_{value}(r,value(r,\tau)))
\end{aligned}
\end{equation} 

where $\Phi_{value}(r,v)$ is defined as follow: 

\begin{equation}
\begin{aligned}
\Phi_{value}(r,v) ={} & \bigvee_{\forall w\in W_v^x} (\Phi_{rw}(w)\wedge rf^r_w\wedge 
					  (\mathbb{C}_w||\mathbb{C}_r\vee \mathbb{C}_w<\mathbb{C}_r)\wedge \\
					& (\bigwedge_{\forall w\neq w'\in W^x}(\mathbb{C}_w' ||\mathbb{C}_w \vee 
					\mathbb{C}_w'<\mathbb{C}_w \vee \mathbb{C}_r<\mathbb{C}_w'))
\end{aligned}
\end{equation}

The constraint $\Phi_{rw}(e)$ requires that every read that must-happen-before 
$e$ should read the same value as that in the input trace. 
The constraint $\Phi_{value}(r,v)$ enforces the read event $r=read(t ,x,v)$ 
to read the value $v$ on $x$ written by any write event $w =write(\_,x,v)$ in $W^x_v$.
Specifically, when the read $r$ reads the value written by the write $w$,
$w$ itself must be feasible, which is ensured by $\Phi_{rw}(w)$. 
%$\Phi_{sw}(r,w)$ is enforced to add the release-acquire synchronization, introduced by read-write pair $(r,w)$. 
$rf(r,w)$ is enforced to require that the read $r$ reads the value written by the write $w$. 
Furthermore, it also subjects to the condition that $\mathbb{C}(r)$ is incomparable with $\mathbb{C}(w)$ or 
$\mathbb{C}(w)$ is smaller than $\mathbb{C}(r)$, and at the same time 
there is no interfering write $w'$ between $w$ and $r$.  
Actually, each $w'$ should be incomparable with $w$, or happen before
$w$ or after $r$. Since not all the events for C++11 programs can be sorted with 
a strict total order, thus when two events are incomparable, we need to enforce
an order between them. 

Based on the definition of $\Phi_{rw}(e)$, the data-validity constraint $\Phi_{rw}$
is a disjunction of the feasibility constraints of all events in $\tau$, defined as follow:

\begin{equation}
\begin{aligned}
\Phi_{rw} = \bigvee_{\forall e\in \tau} (\Phi_{rw}(e))
\end{aligned}
\end{equation} 

Note that the formula $\Phi$ constructed in this section
encodes all the feasible executions that can be inferred from the 
input trace $\tau$. Each solution of the VC variables to $\tau$ corresponds 
to an interleaving. The size of $\Phi$ is cubic in number of reads and writes in $\tau$, 
and the number of its solutions can be exponential. However, we do not need to
produce all the solutions but only check them at the same time against the properties,
described in Section~\ref{sec:check}. 

\paragraph{Encode memory coherence constraints $\Phi_{co}$}

Memory model makes the key restriction on the values that memory actions can read. 
Specifically, for each location, four types of coherence restrictions 
(CoRR, CoRW, CoWR, CoWW) are applied to the 
values that a read event can read. Each restriction explains the forbidden behavior of 
an execution. Thus, $\Phi_{co}$ can be constructed by the conjunction of the four
types of restrictions, as described by $\Phi_{co}=\Phi_{corr}\wedge \Phi_{corw}
\wedge\Phi_{cowr}\wedge\Phi_{coww}$. 
Figure~\ref{fig:CO} describes four forbidden example executions enforced
by each restriction. 

\begin{figure*}%[t]
\centering\includegraphics[scale=0.65]{CO.pdf} %[width=6in]
\caption{Four types of coherence restrictions.}
\label{fig:CO}
\end{figure*}

Specifically, let $L$ be all the atomic locations, and $R^x$ be the set of 
all the reads on location $x$. 

\textbf{CoRR} forbids two reads with happens-before relation (such as two reads
in a single thread) from observing two writes in an order inconsistent with modification order. 
To forbid such inconsistent executions as described in Figure~\ref{fig:CO}(a), 
we encode $\Phi_{corr}$ as follow: 

\begin{equation}
\begin{aligned}
\Phi_{corr} = \bigwedge_{\forall x\in L}(\bigwedge_{\substack{\forall a,b\in W^x\\c,d\in R^x}} 
(rf^a_c\wedge rf^b_d\wedge\mathbb{C}_c<\mathbb{C}_d)\rightarrow mo(a,b))
\end{aligned}
\end{equation} 

\textbf{CoRW} requires that a read that is happens-before a 
write should not be able to read from a later write in modification order.
As described in Figure~\ref{fig:CO}(b), the read $b$ can not read from
the write $a$, because $b$ happens-before $c$ and $a$ is a later write 
with $c$ in the modification order. To forbid such inconsistent executions, we 
encode $\Phi_{corw}$ as follow: 

\begin{equation}
\begin{aligned}
\Phi_{corw} = \bigwedge_{\forall x\in L}(\bigwedge_{\substack{\forall a,c\in W^x\\b\in R^x}}
(rf^a_b\wedge\mathbb{C}_b<\mathbb{C}_c)\rightarrow mo(a,c))
\end{aligned}
\end{equation} 

\textbf{CoWR} requires that when a write happens-before a read, then the read should 
not be able to read from an earlier write than the given write in modification order. 
For example, in Figure~\ref{fig:CO}(c),
$c$ can not read from $a$. To forbid such inconsistent executions, we 
encode $\Phi_{cowr}$ as follow: 

\begin{equation}
\begin{aligned}
\Phi_{cowr} = \bigwedge_{\forall x\in L}(\bigwedge_{\substack{\forall a,b\in W^x\\c\in R^x}}
(rf^a_c\wedge\mathbb{C}_b<\mathbb{C}_c)\rightarrow mo(b,a))
\end{aligned}
\end{equation} 

\textbf{CoWW} requires modification order to agree with happens-before. 
Specifically, when two writes to the same location have happens-before relation,
then they are related by modification order in the same direction. 
Taking Figure~\ref{fig:CO}(d) for example, $a$ happens-before $b$, thus $b$ 
must be a latter write than $a$ in modification order. 
We use $\Phi_{coww}$ to forbid such inconsistent executions, which is defined 
as follow: 

\begin{equation}
\begin{aligned}
\Phi_{cowr} = \bigwedge_{\forall x\in L}(\bigwedge_{\substack{\forall a,b\in W}}
(\mathbb{C}_a<\mathbb{C}_b)\rightarrow mo(a,b))
\end{aligned}
\end{equation} 



\subsection{Property Checking}
\label{sec:check}

\subsubsection{Indeterminate Read}

A read with no incoming reads-from edge is of indeterminate value. 

\subsubsection{Unsequenced Race}

Two non-atomic actions on the same thread and location, one of which is 
a write, participate in an unsequenced race if neither is sequenced before the other.

\subsubsection{Data Race}
Two actions on different threads but the same location, with at least 
one a write and one non-atomic, participate in a data race if neither 
happens-before the other. A program that has a consistent execution 
with a data race, like the one below, has undefined behavior.

\subsection{Identify Unexplored Consistent Executions}
\label{sec:identify}

Our approach uses MCM to catch all the executions in which each read
reads the same value, based on an input trace $\tau$, an then
check all the executions at the same time. 
To explore other uncaught executions, we generate seed interleavings
which have at least one new behavior: one read event reads a different
value, as long as these interleavings are feasible. This approach can guarantee
that no two seed interleavings are redundant from the view of reading 
different values. Furthermore, our approach consider all feasible combinations
of read values, thus it guarantee that no unexplored seed interleaving will
be missed and thus cover the entire state-space eventually. 

Different from applying such approach on concurrent program with sequential
consistent memory model, when considering weak memory model...

%\appendix
%\section{Appendix Title}

%This is the text of the appendix, if you need one.

%\acks
%Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}
\bibliography{references}
% The bibliography should be embedded for final submission.

%\begin{thebibliography}{}
%\softraggedright
%\end{thebibliography}











\end{document}
