//
// Created by aser on 6/8/17.
//

#ifndef INSTRUMENT_CONSTRAINTMODELGENERATOR_H
#define INSTRUMENT_CONSTRAINTMODELGENERATOR_H

#include <iostream>
#include <map>
#include <vector>
#include <string>

#include "Z3Solver.h"
#include "SWRelation.h"
//#include "Schedule.h"

namespace  checker {
    class Action;
    class RWAction;
    class LockAction;
    class FenceAction;
    class Executor;
    class Solver;

    class ConstModelGen {
    protected:
        Z3Solver* z3solver;
        Solver* solver;

        double numB; //number of memory order constraints
        double numRW; //number of read-write constraints
        double numLO; //number of locking order constraints
        double numPO; //number of partial order synchronization constraints
        double numPC; //number of path constraints
        double numUnkownVars; //number of unknown variables
        Executor* exe;
        //std::map<Action*, Action*> swPairs;
        set<SWRelation*> swRelations;

    private:
        bool isFirst;
        bool consistency;
        std::set<RWAction*> prefix;
        std::map<std::pair<RWAction*, int64_t >, std::string > tmpRWConstraint;
        std::map<Action*, std::string> guaranteeStore;
        //std::vector<Action *> getWritesForRead(Action readop, std::vector<Action> writeset);

    public:
        ConstModelGen(Executor* exe, Solver* s, Z3Solver* solver) {
            this->exe = exe;
            this->solver = s;
            z3solver = solver;
            initialize();
            consistency = true;
            isFirst = false;
        }

        ~ConstModelGen();

        void initialize();
        void setFirst() { isFirst = true; }
        std::string addBasicConstraints();
        void addASWRelation();
        void declareIntVar(std::string name);
        std::string declareIntVar2(std::string name, int min, int max);
        std::string declareIntVar2(std::string name);
        void declareIntVar(std::string name, int min, int max);
        void declareIntVarGE(std::string name, int min);
        std::string declareIntVarGE2(std::string name, int min);
        std::string addRFRelation(RWAction* read, RWAction* write, int val);
        std::string addRWRelation(std::map<RWAction*, int64_t> pairs,
                                  std::map<RWAction*, int64_t> parents,
                                  //std::set<std::string> &enforcedRFs,
                                  RWAction* read, int64_t val);

        std::string guaranteeReachability(std::map<RWAction*, int64_t> pairs,
                                          std::map<RWAction*, int64_t > parents,
                                          /*std::set<std::string> &enforcedRFs,*/
                                          Action* action, bool forRead);

        std::set<Action*> filterActions(std::set<Action*> list);

        bool addRWRelations(std::map<RWAction*, int64_t> pairs,
                            std::set<std::string> &enforcedRFs);
                            //std::set<std::string> &binaryRelations);
        bool addSWConstraints();
        std::string addMOConstraints();
        std::string addSCConstraints();
        std::string addLockConstraints();
        void addFenceConstraints();

        void enforceFenceAcquire(FenceAction* fence, RWAction* write, RWAction* read,
                                RWAction* firstW, int writeNum);
        void enforceReleaseFence(FenceAction* fence, RWAction* write, RWAction* read,
                                RWAction* firstW, int writeNum);
        void enforceFenceFence(FenceAction* rFence, FenceAction* aFence,
                              RWAction* write, RWAction* read, RWAction* firstW, int writeNum);
        void enforceReleaseAcquire(RWAction* write, RWAction* read);

            // add the swRelations generated by two locks-unlock pairs
        void enforceLockSW(std::pair<LockAction*, LockAction*> pair1, std::pair<LockAction*, LockAction*> pair2);

        std::string enforceMOConsistent();
        std::string enforceRFConsistent();
        std::string enforceRFConsistent_optimized();
        std::string enforceRFConsistent_optimized_and_shareWithPrefix(std::set<RWAction*> prefix);
        std::string enforceConsistentConstraint(std::set<RWAction*> prefix);

        bool identifySWFence(RWAction* read, RWAction* write);
        bool isEnforceSWRelation(Action* a, Action* b);
        Action* getRelSeqHead(RWAction* write); // get the head of the release sequence that 'write' belong to

        bool overlap(std::set<Action*> set1, std::set<Action*> set2);
        bool isAcquireFence(FenceAction* action);
        bool isReleaseFence(FenceAction* action);
        bool isAcquire(RWAction* fence);
        bool isRelease(RWAction* fence);

        void printActionSet(set<Action*> list);
        bool getConsistency() { return consistency; }

        void setPrefix(std::set<RWAction*> pre) { prefix = pre; }

        RWAction* nearestPreviousWrite(Action* action);
        RWAction* nearestPostRead(Action* action);
        //std::string addLoopDepCondition()
    };
}

#endif //INSTRUMENT_CONSTRAINTMODELGENERATOR_H

