//===- Hello.cpp - Example code from "Writing an LLVM Pass" ---------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file implements two versions of the LLVM "Hello World" pass described
// in docs/WritingAnLLVMPass.html
//
//===----------------------------------------------------------------------===//

#include <iostream>

#include "llvm/ADT/Statistic.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/BasicBlock.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Constants.h"
#include "llvm/Pass.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Transforms/Utils/BasicBlockUtils.h"
using namespace llvm;

#define DEBUG_TYPE "MyInstrument"

STATISTIC(HelloCounter, "Counts number of functions greeted");

namespace {
  class codeInstr : public ModulePass {
    std::map<std::string, Function*> myFunctions;
    std::map<std::string, int> orderToInt = {{"not_atomic", 0}, {"unordered", 1}, {"monotonic", 2}, 
        {"consume", 3}, {"acquire", 4}, {"release", 5}, {"acq_rel", 6}, {"seq_cst", 7}};
    
    BasicBlock::iterator BBIt; 
    
    void addSpecialFunctions(Module &M) {
      // parameter types
      std::vector<Type*> paramTypes;
      //PointerType* pType = PointerType::get(Type::getInt8PtrTy(inst->getContext()), 0);
      
      // add store function "preStore"
      PointerType* pType = Type::getInt8PtrTy(M.getContext());
      paramTypes.push_back(pType);
      paramTypes.push_back(Type::getInt8Ty(M.getContext()));
      FunctionType *FT = FunctionType::get(Type::getVoidTy(M.getContext()), paramTypes, false);
      Function *storeF_char = Function::Create(FT, Function::ExternalLinkage, "preNonAtomicStore_char", &M);
      myFunctions["preNonAtomicStore_char"] = storeF_char; 
      
      paramTypes.clear();
      paramTypes.push_back(pType);
      paramTypes.push_back(Type::getInt32Ty(M.getContext()));
      FT = FunctionType::get(Type::getVoidTy(M.getContext()), paramTypes, false);
      Function *storeF_int = Function::Create(FT, Function::ExternalLinkage, "preNonAtomicStore_int", &M);
      myFunctions["preNonAtomicStore_int"] = storeF_int;

      paramTypes.clear();
      paramTypes.push_back(pType);
      paramTypes.push_back(Type::getInt64Ty(M.getContext()));
      FT = FunctionType::get(Type::getVoidTy(M.getContext()), paramTypes, false);
      Function *storeF_double = Function::Create(FT, Function::ExternalLinkage, "preNonAtomicStore_double", &M);
      myFunctions["preNonAtomicStore_double"] = storeF_double;

      paramTypes.clear();
      paramTypes.push_back(pType);
      paramTypes.push_back(Type::getInt8Ty(M.getContext()));
      paramTypes.push_back(Type::getInt32Ty(M.getContext()));
      FT = FunctionType::get(Type::getVoidTy(M.getContext()), paramTypes, false);
      Function *atomicStoreF_char = Function::Create(FT, Function::ExternalLinkage, "preAtomicStore_char", &M);
      myFunctions["preAtomicStore_char"] = atomicStoreF_char; 

      paramTypes.clear();
      paramTypes.push_back(pType);
      paramTypes.push_back(Type::getInt32Ty(M.getContext()));
      paramTypes.push_back(Type::getInt32Ty(M.getContext()));
      FT = FunctionType::get(Type::getVoidTy(M.getContext()), paramTypes, false);
      Function *atomicStoreF_int = Function::Create(FT, Function::ExternalLinkage, "preAtomicStore_int", &M);
      myFunctions["preAtomicStore_int"] = atomicStoreF_int; 
      std::cerr << "add a function: preStore\n";
      //storeF->dump();

      paramTypes.clear();
      paramTypes.push_back(pType);
      paramTypes.push_back(Type::getInt64Ty(M.getContext()));
      paramTypes.push_back(Type::getInt32Ty(M.getContext()));
      FT = FunctionType::get(Type::getVoidTy(M.getContext()), paramTypes, false);
      Function *atomicStoreF_double = Function::Create(FT, Function::ExternalLinkage, "preAtomicStore_double", &M);
      myFunctions["preAtomicStore_double"] = atomicStoreF_double;

      // add load function "preLoad"
      paramTypes.clear();
      paramTypes.push_back(pType);
      paramTypes.push_back(Type::getInt8Ty(M.getContext()));
      FT = FunctionType::get(Type::getVoidTy(M.getContext()), paramTypes, false);
      Function *loadF_char = Function::Create(FT, Function::ExternalLinkage, "preNonAtomicLoad_char", &M);
      myFunctions["preNonAtomicLoad_char"] = loadF_char;
      
      paramTypes.clear();
      paramTypes.push_back(pType);
      paramTypes.push_back(Type::getInt32Ty(M.getContext()));
      FT = FunctionType::get(Type::getVoidTy(M.getContext()), paramTypes, false);
      Function *loadF_int = Function::Create(FT, Function::ExternalLinkage, "preNonAtomicLoad_int", &M);
      myFunctions["preNonAtomicLoad_int"] = loadF_int;

      paramTypes.clear();
      paramTypes.push_back(pType);
      paramTypes.push_back(Type::getInt64Ty(M.getContext()));
      FT = FunctionType::get(Type::getVoidTy(M.getContext()), paramTypes, false);
      Function *loadF_double = Function::Create(FT, Function::ExternalLinkage, "preNonAtomicLoad_double", &M);
      myFunctions["preNonAtomicLoad_double"] = loadF_double;
      
      paramTypes.clear();
      paramTypes.push_back(pType);
      paramTypes.push_back(Type::getInt8Ty(M.getContext()));
      paramTypes.push_back(Type::getInt32Ty(M.getContext()));
      FT = FunctionType::get(Type::getVoidTy(M.getContext()), paramTypes, false);
      Function *atomicLoadF_char = Function::Create(FT, Function::ExternalLinkage, "preAtomicLoad_char", &M);
      myFunctions["preAtomicLoad_char"] = atomicLoadF_char; 
      
      paramTypes.clear();
      paramTypes.push_back(pType);
      //paramTypes.push_back(Type::getInt32Ty(M.getContext()));
      paramTypes.push_back(Type::getInt32Ty(M.getContext()));
      FT = FunctionType::get(Type::getInt32Ty(M.getContext()), paramTypes, false);
      Function *atomicLoadF_int = Function::Create(FT, Function::ExternalLinkage, "preAtomicLoad_int", &M);
      myFunctions["preAtomicLoad_int"] = atomicLoadF_int;

      paramTypes.clear();
      paramTypes.push_back(pType);
      paramTypes.push_back(Type::getInt64Ty(M.getContext()));
      paramTypes.push_back(Type::getInt32Ty(M.getContext()));
      FT = FunctionType::get(Type::getVoidTy(M.getContext()), paramTypes, false);
      Function *atomicLoadF_double = Function::Create(FT, Function::ExternalLinkage, "preAtomicLoad_double", &M);
      myFunctions["preAtomicLoad_double"] = atomicLoadF_double;

      paramTypes.clear();
      paramTypes.push_back(Type::getInt32Ty(M.getContext()));
      FT = FunctionType::get(Type::getVoidTy(M.getContext()), paramTypes, false);
      Function *fenceF = Function::Create(FT, Function::ExternalLinkage, "preFence", &M);
      myFunctions["preFence"] = fenceF;

      paramTypes.clear();
      paramTypes.push_back(pType);
      paramTypes.push_back(Type::getInt32Ty(M.getContext()));
      paramTypes.push_back(Type::getInt32Ty(M.getContext()));
      paramTypes.push_back(Type::getInt32Ty(M.getContext()));
      paramTypes.push_back(Type::getInt32Ty(M.getContext()));
      FT = FunctionType::get(Type::getVoidTy(M.getContext()), paramTypes, false);
      Function* cmpXchgIntF = Function::Create(FT, Function::ExternalLinkage, "preCmpXchg_int", &M);
      myFunctions["preCmpXchg_int"] = cmpXchgIntF;

      paramTypes.clear();
      paramTypes.push_back(pType);
      paramTypes.push_back(Type::getInt32Ty(M.getContext()));
      paramTypes.push_back(Type::getInt32Ty(M.getContext()));
      FT = FunctionType::get(Type::getVoidTy(M.getContext()), paramTypes, false);
      Function *rmwXchgF = Function::Create(FT, Function::ExternalLinkage, "preRMW_Xchg", &M);
      myFunctions["preRMW_Xchg"] = rmwXchgF; 
      Function *rmwAddF = Function::Create(FT, Function::ExternalLinkage, "preRMW_Add", &M);
      myFunctions["preRMW_Add"] = rmwAddF;
      Function *rmwSubF = Function::Create(FT, Function::ExternalLinkage, "preRMW_Sub", &M);
      myFunctions["preRMW_Sub"] = rmwSubF;
      Function *rmwAndF = Function::Create(FT, Function::ExternalLinkage, "preRMW_And", &M);
      myFunctions["preRMW_And"] = rmwAndF;
      Function *rmwNandF = Function::Create(FT, Function::ExternalLinkage, "preRMW_Nand", &M);
      myFunctions["preRMW_Nand"] = rmwNandF;
      Function *rmwOrF = Function::Create(FT, Function::ExternalLinkage, "preRMW_Or", &M);
      myFunctions["preRMW_Or"] = rmwOrF;
      Function *rmwXorF = Function::Create(FT, Function::ExternalLinkage, "preRMW_Xor", &M);
      myFunctions["preRMW_Xor"] = rmwXorF;
      Function *rmwMaxF = Function::Create(FT, Function::ExternalLinkage, "preRMW_Max", &M);
      myFunctions["preRMW_Max"] = rmwMaxF;
      Function *rmwMinF = Function::Create(FT, Function::ExternalLinkage, "preRMW_Min", &M);
      myFunctions["preRMW_Min"] = rmwMinF;
      Function *rmwUMaxF = Function::Create(FT, Function::ExternalLinkage, "preRMW_UMax", &M);
      myFunctions["preRMW_UMax"] = rmwUMaxF;
      Function *rmwUMinF = Function::Create(FT, Function::ExternalLinkage, "preRMW_UMin", &M);
      myFunctions["preRMW_UMin"] = rmwUMinF;
    }

    
    void instrInvoke(Instruction* inst) {
      //inst->dump();
      InvokeInst* invokeInst;
      if ((invokeInst = dyn_cast<InvokeInst>(inst)) == NULL)
          return ;
      Function* func = invokeInst->getCalledFunction();
      if (func == NULL)
          return ;
      //std::cerr << "ffff: " << func << "\n";
      //errs() << "Func: " << func->getName().str() << "\n";
    }

    void instrCall(Instruction* inst) {
      /*inst->dump();
      CallInst* cInst;
      if ((cInst = dyn_cast<CallInst>(inst)) == NULL)
          return ;
      
      Function* func = cInst->getCalledFunction();
      errs() << "Func: " << func->getName().str() << "\n";
      if (func->isIntrinsic()) {
        errs() << "Is Intrinsic!\n";
        return ;
      }*/

    }
    void instrNonAtomicLoad(LoadInst* loadI) {
      errs() << "Identify a non-atomic load!\n";
      
      Function* func;
      if (loadI->getType() == Type::getInt8Ty(loadI->getContext())) 
          func = myFunctions["preNonAtomicLoad_char"];
      else if (loadI->getType() == Type::getInt32Ty(loadI->getContext()))
          func = myFunctions["preNonAtomicLoad_int"];
      else if (loadI->getType() == Type::getInt64Ty(loadI->getContext()))
          func = myFunctions["preNonAtomicLoad_double"];
      else {
          loadI->getType()->dump();
          errs() << "Not handle this type for non-atomic load!\n";
          return ;
      }

      loadI->dump();

      std::vector<Value*> params;
      Value* param = loadI->getOperand(0);
      if (param->getType() != Type::getInt8PtrTy(loadI->getContext())) {
          BitCastInst* castInst = new BitCastInst(param, Type::getInt8PtrTy(loadI->getContext()), "myCast", loadI);
          param = castInst;
      }
      //LoadInst* newLoadI = new LoadInst(loadI->getOperand(0), "myLoad", loadI);
      params.push_back(param);
      params.push_back(loadI);
      CallInst* callI = CallInst::Create(func->getFunctionType(), func, params, "");
      //BasicBlock* pb = loadI->getParent();
      //pb->getInstList().insertAfter(loadI, callI);
      callI->insertAfter(loadI);
    }

    void instrAtomicLoad(LoadInst* loadI) {
      std::string order = toIRString(loadI->getOrdering());
      errs() << "Identify an atomic load!: " << order << "\n";
      Value* o = ConstantInt::get( Type::getInt32Ty(loadI->getContext()), orderToInt[order]);
      
      Function* func;
      if (loadI->getType() == Type::getInt8Ty(loadI->getContext()))
          func = myFunctions["preAtomicLoad_char"];
      else if (loadI->getType() == Type::getInt32Ty(loadI->getContext()))
          func = myFunctions["preAtomicLoad_int"];
      else if (loadI->getType() == Type::getInt64Ty(loadI->getContext()))
          func = myFunctions["preAtomicLoad_double"];
      else {
          loadI->getType()->dump();
          errs() << "Not handle this type for atomic load!\n";
          return ;
      }

      std::vector<Value*> params;
      Value* param = loadI->getOperand(0);
      if (param->getType() != Type::getInt8PtrTy(loadI->getContext())) {
          BitCastInst* castInst = new BitCastInst(param, Type::getInt8PtrTy(loadI->getContext()), "myCast", loadI);
          param = castInst;
      }
      
      //LoadInst* newLoadI = new LoadInst(loadI->getOperand(0), "myLoad", loadI);
      params.push_back(param);
      //params.push_back(loadI);
      params.push_back(o);
      CallInst* callI = CallInst::Create(func->getFunctionType(), func, params, "");
      //callI->insertAfter(loadI);
      func->dump();
      loadI->dump();
      callI->dump();

      BasicBlock::iterator ii(loadI);
      ReplaceInstWithInst(loadI->getParent()->getInstList(), BBIt, callI);
      callI->dump();
      std::cout << "end!\n";
      callI->getParent()->dump();
    }

    void instrLoad(Instruction* inst) {
      //inst->dump();
      LoadInst* loadI = dyn_cast<LoadInst>(inst);
      if (loadI->isAtomic() == false)
          instrNonAtomicLoad(loadI);
      else 
          instrAtomicLoad(loadI);
      std::cout << "end2\n";
    }

    void instrNonAtomicStore(StoreInst* storeI) {
      errs() << "Identify a non-atomic store! \n";

      Function* func;
      Value* v = storeI->getOperand(0);
      if (v->getType() == Type::getInt8Ty(storeI->getContext())) 
          func = myFunctions["preNonAtomicStore_char"];
      else if (v->getType() == Type::getInt32Ty(storeI->getContext()))
          func = myFunctions["preNonAtomicStore_int"];
      else if (v->getType() ==  Type::getInt64Ty(storeI->getContext()))
          func = myFunctions["preNonAtomicStore_double"];
      else {
          v->getType()->dump();
          errs() << "Not handle this type for non-atomic store!\n";
          return ;
      }

      std::vector<Value*> params;
      Value* param = storeI->getOperand(1);
      if (param->getType() != Type::getInt8PtrTy(storeI->getContext())) {
          BitCastInst* castInst = new BitCastInst(param, Type::getInt8PtrTy(storeI->getContext()), "myCast", storeI);
          param = castInst;
      }
      params.push_back(param);
      params.push_back(storeI->getOperand(0));
      CallInst::Create(func->getFunctionType(), func, params, "", storeI);
    }

    void instrAtomicStore(StoreInst* storeI) {
      //errs() << toIRString(storeI->getOrdering()) << "\n";
      std::string order = toIRString(storeI->getOrdering());
      errs() << "Identify an atomic store!: " << order << "\n";
      Value* o = ConstantInt::get( Type::getInt32Ty(storeI->getContext()), orderToInt[order]);

      Function* func;
      Value* v = storeI->getOperand(0);
      if (v->getType() ==  Type::getInt8Ty(storeI->getContext()))
          func = myFunctions["preAtomicStore_char"];
      else if (v->getType() == Type::getInt32Ty(storeI->getContext()))
          func = myFunctions["preAtomicStore_int"];
      else if (v->getType() == Type::getInt64Ty(storeI->getContext()))
          func = myFunctions["preAtomicStore_double"];
      else {
          v->getType()->dump();
          errs() << "Not handle this type for atomic store!\n";
          return ;
      }

      std::vector<Value*> params;
      Value* param = storeI->getOperand(1);
      if (param->getType() != Type::getInt8PtrTy(storeI->getContext())) {
          BitCastInst* castInst = new BitCastInst(param, Type::getInt8PtrTy(storeI->getContext()), "myCast", storeI);
          param = castInst;
      }
      params.push_back(param);
      params.push_back(storeI->getOperand(0));
      params.push_back(o);
      CallInst::Create(func->getFunctionType(), func, params, "", storeI);
    }

    void instrStore(Instruction* inst) {
      StoreInst* storeI = dyn_cast<StoreInst>(inst);
      if (storeI->isAtomic() == false)
          instrNonAtomicStore(storeI);
      else 
          instrAtomicStore(storeI);
    }

    void instrFence(Instruction* inst) {
        FenceInst* fenceI = dyn_cast<FenceInst>(inst);
        std::string order = toIRString(fenceI->getOrdering());
        errs() << "Identify a fence!: " << order << "\n";
        Value* o = ConstantInt::get( Type::getInt32Ty(fenceI->getContext()), orderToInt[order]);

        Function* func = myFunctions["preFence"];
        std::vector<Value*> params;
        
        params.push_back(o);
        CallInst::Create(func->getFunctionType(), func, params, "", fenceI);
    }

    void instrCmpXchg(Instruction* inst) {
        AtomicCmpXchgInst* cmpXchgI = dyn_cast<AtomicCmpXchgInst>(inst);
        std::string successOrder = toIRString(cmpXchgI->getSuccessOrdering());
        std::string failureOrder = toIRString(cmpXchgI->getFailureOrdering());
        errs() << "Identify a cmpXchg!: " << successOrder << " " << failureOrder << "\n";

        Value* o1 = ConstantInt::get( Type::getInt32Ty(cmpXchgI->getContext()), orderToInt[successOrder]);
        Value* o2 = ConstantInt::get( Type::getInt32Ty(cmpXchgI->getContext()), orderToInt[failureOrder]);

        std::vector<Value*> params;
        Value* v1 = cmpXchgI->getPointerOperand();
        Value* v2 = cmpXchgI->getCompareOperand();
        Value* v3 = cmpXchgI->getNewValOperand();

        //v1->dump(), v2->dump(), v3->dump();

        if (v1->getType() != Type::getInt8PtrTy(cmpXchgI->getContext())) {
          BitCastInst* castInst = new BitCastInst(v1, Type::getInt8PtrTy(cmpXchgI->getContext()), "myCast", cmpXchgI);
          v1 = castInst;
        }

        if (v3->getType() == Type::getInt32Ty(cmpXchgI->getContext())) {
            Function* func = myFunctions["preCmpXchg_int"];
            params.push_back(v1);
            params.push_back(v2);
            params.push_back(v3);
            params.push_back(o1);
            params.push_back(o2);
            CallInst::Create(func->getFunctionType(), func, params, "", cmpXchgI);
        } else {
            v3->getType()->dump();
            errs() << "Not handle this type of cmpXchg inst!\n";
            return ;
        }
        
    }

    void instrRMW(Instruction* inst) {
        AtomicRMWInst* rmwI = dyn_cast<AtomicRMWInst>(inst);
        AtomicRMWInst::BinOp op = rmwI->getOperation();
        std::string order = toIRString(rmwI->getOrdering());
        Value* o = ConstantInt::get( Type::getInt32Ty(rmwI->getContext()), orderToInt[order]);

        Value* v1 = rmwI->getPointerOperand();
        Value* v2 = rmwI->getValOperand();

        if (v1->getType() != Type::getInt8PtrTy(rmwI->getContext())) {
          BitCastInst* castInst = new BitCastInst(v1, Type::getInt8PtrTy(rmwI->getContext()), "myCast", rmwI);
          v1 = castInst;
        }
        
        std::vector<Value*> params;
        params.push_back(v1);
        params.push_back(v2);
        params.push_back(o);
        switch (op) {
            case AtomicRMWInst::BinOp::Xchg: {
                                             
                                             }
            case AtomicRMWInst::BinOp::Add: { 
                Function* func = myFunctions["preRMW_Add"];
                CallInst::Create(func->getFunctionType(), func, params, "", rmwI);
                break; 
            }
            case AtomicRMWInst::BinOp::Sub: {}
            case AtomicRMWInst::BinOp::And: {}
            case AtomicRMWInst::BinOp::Nand: {}
            case AtomicRMWInst::BinOp::Or: {}
            case AtomicRMWInst::BinOp::Xor: {}
            case AtomicRMWInst::BinOp::Max: {}
            case AtomicRMWInst::BinOp::Min: {}
            case AtomicRMWInst::BinOp::UMax: {}
            case AtomicRMWInst::BinOp::UMin: {}
            default: {
                inst->dump();
                errs() << "Not handle this type of cmpXchg inst!\n";
                return ;
            }
        }
    }

    void instrInst(Instruction* inst) {
      switch (inst->getOpcode()) {
        case Instruction::Call:
            instrCall(inst);
            break ;
        case Instruction::Invoke:
            instrInvoke(inst);
            break;
        case Instruction::Load:
            instrLoad(inst);
            break;
        case Instruction::Store:
            instrStore(inst);
            break;
        case Instruction::Fence:
            instrFence(inst);
            break;
        case Instruction::AtomicCmpXchg:
            instrCmpXchg(inst);
            break;
        case Instruction::AtomicRMW:
            instrRMW(inst);
            break;
        default: 
            break ;
      }
    }

    void instrFunc(Function* func) {
      for (Function::iterator it = func->begin(); 
              it != func->end(); ++it) {
        //BasicBlock bb = *it;
        for (BBIt = it->begin();
                BBIt != it->end(); ++BBIt) {
            std::cout << "ssss: \n";
            Instruction* inst = &*BBIt;
            inst->dump();
            instrInst(inst);
            std::cout << "sss2:\n";
        }
      }
    }

    bool runOnModule(Module &M) override {
      std::cout << "Instrument code: begin!\n";
      addSpecialFunctions(M);
      for (Module::iterator it = M.begin(); 
              it != M.end(); ++it) {
        Function* func = &*it;
        instrFunc(func);
      }
      std::cout << "Instrument code: end!\n";
      return true;
    }
  
  public:
    static char ID; 
    codeInstr() : ModulePass(ID) {}
  };
}

char codeInstr::ID = 0;
static RegisterPass<codeInstr> 
Z("codeInstr", "Instrument code Pass");
